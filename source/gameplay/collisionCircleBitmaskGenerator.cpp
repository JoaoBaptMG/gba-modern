//--------------------------------------------------------------------------------
// collisionCircleBitmapGenerator.cpp
//--------------------------------------------------------------------------------
// Provide collision detection routines and utilities
//--------------------------------------------------------------------------------
#include "math/stdfixed.hpp"
#include "math/vec2.hpp"

#include <array>
#include <cstdint>
#include <algorithm>
#include <type_traits>

#include "data/BitmaskData.hpp"

#include "text/mGBADebugging.hpp"

// Necessary, otherwise gcc will not respect the 4-byte alignment necessary
template <std::size_t N>
static constexpr auto align32(std::array<u16, N> data)
{
    std::array<u32, (N+1)/2> aligned{};
    for (std::size_t i = 0; i < N; i++)
        aligned[i/2] |= data[i] << (16 * (i%2));

    return aligned;
}

// Statically generate a bitmask for a circle of radius Radius.
// The bitmask is stored in a std::array of right size to be
// consumed by the bitmask routines and (if used correctly)
// will be stored on ROM
template <std::size_t Radius>
static constexpr auto generateCircleBitmask()
{
    constexpr auto ClusterSize = (2*Radius+15)/16;
    constexpr auto PxSize = 2*Radius;

    std::array<u16, ClusterSize*PxSize+2> data{};
    data[0] = PxSize << 7;
    data[1] = PxSize << 7;

    for (std::size_t j = 0; j < PxSize; j++)
        for (std::size_t i = 0; i < PxSize; i++)
        {
            auto ti = i + 0.5 - Radius;
            double tj = j + 0.5 - Radius;

            if (ti*ti + tj*tj <= Radius*Radius)
                data[2 + ClusterSize*j + (i/16)] |= 1 << (i%16);
        }

    return align32(data);
}

// Generate a tuple having the bitmasks and the radii requested in the
// parameter pack Rs. The tuple is designed so the Arrays comes last so
// the empty-base-class optimization can guarantee that only Arrays occupies
// memory in ROM, since std::index_sequence is an empty class
template <std::size_t... Rs>
static constexpr auto collectBitmasks()
{
    constexpr auto Ids = std::index_sequence<Rs...>();
    constexpr auto Arrays = std::make_tuple(generateCircleBitmask<Rs>()...);
    return std::make_tuple(Ids, Arrays);
}

// MaxOfSequence is easy. Given a std::index_sequence, returns the max of the
// integers there
template <typename T>
struct MaxOfSequence {};

template <std::size_t... Nums>
struct MaxOfSequence<std::index_sequence<Nums...>>
    : std::integral_constant<std::size_t, std::max({Nums...})> {};

// setBitmasks is a helper function that will set the right index to the right pointer
// on the bitmask array, so it can be addressed by radius on the collision routines
template <typename T, std::size_t Size, std::size_t... Indices, std::size_t... Is>
static constexpr void setBitmasks(std::array<const void*, Size>& arr, const T& values, 
    std::index_sequence<Indices...>, std::index_sequence<Is...>)
{
    ((arr[Indices] = &std::get<Is>(values)), ...);
}

// Takes the tuple generated by collectBitmasks and create an array that maps the requested
// radius to the correct bitmask. It will only do so for the bitmasks that were generated
// in collectBitmasks
template <typename T>
static constexpr auto attachBitmasks(const T& values)
{
    const auto& bitmasks = std::get<1>(values);
    using Ids = std::decay_t<decltype(std::get<0>(values))>;
    std::array<const void*, MaxOfSequence<Ids>::value+1> array{};

    constexpr auto Size = Ids::size();
    setBitmasks(array, bitmasks, Ids{}, std::make_index_sequence<Size>{});

    return array;
}

// There is where you request specific sizes of bitmasks
constexpr static const auto dCircleBitmasks = collectBitmasks<1, 2, 8>();
constexpr extern const auto CircleBitmasks = attachBitmasks(dCircleBitmasks);

extern "C" void assertRadiusDoesNotExist(std::size_t dummy, std::size_t radius)
{
    if (mgba::isEnabled())
        mgba::log(mgba::Log::Fatal, "Circle bitmask was not generated for radius ", radius);

    for (;;) asm volatile ("" ::: "memory");
}
